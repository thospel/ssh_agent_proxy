#!/usr/bin/env python3

import asyncio
import sys
import struct
import os
import hashlib
from pathlib import Path
from typing import List, Tuple
from enum import Enum

# Define SSH agent protocol message types as an enum
class MessageType(Enum):
    REQUEST_IDENTITIES = 11
    IDENTITIES_ANSWER = 12
    SIGN_REQUEST = 13
    SIGN_RESPONSE = 14
    FAILURE = 5
    SUCCESS = 6
    EXTENSION = 27

class SSHAgentProxy:
    def __init__(self, agent_socket_path: str, directory: Path):
        self.agent_socket_path = agent_socket_path
        self.directory = directory

    async def handle_client(self, reader: asyncio.StreamReader, writer: asyncio.StreamWriter, key: bytes) -> None:
        agent_reader, agent_writer = await asyncio.open_unix_connection(self.agent_socket_path)
        print("Connection made", file=sys.stderr)

        async def forward_data(src_reader: asyncio.StreamReader, dest_writer: asyncio.StreamWriter, direction: str) -> None:
            try:
                while True:
                    data = await src_reader.read(4)
                    if not data:
                        break
                    msg_len = struct.unpack(">I", data)[0]
                    msg_data = await src_reader.read(msg_len)
                    if not msg_data:
                        break

                    if msg_data[0] == MessageType.IDENTITIES_ANSWER.value:
                        msg_data = self.filter_identities(msg_data, key)
                        msg_len = len(msg_data)
                        data = struct.pack(">I", msg_len)

                    dest_writer.write(data + msg_data)
                    await dest_writer.drain()
                    self.print_verbose(data + msg_data, key, direction)
            except asyncio.CancelledError:
                pass
            finally:
                dest_writer.close()
                await dest_writer.wait_closed()

        try:
            await asyncio.gather(
                forward_data(reader, agent_writer, "to agent"),
                forward_data(agent_reader, writer, "from agent")
            )
        except asyncio.CancelledError:
            pass
        finally:
            writer.close()
            await writer.wait_closed()
            agent_writer.close()
            await agent_writer.wait_closed()
            print("Connection lost", file=sys.stderr)

    def filter_identities(self, msg_data: bytes, key: bytes) -> bytes:
        num_identities = struct.unpack(">I", msg_data[1:5])[0]
        offset = 5
        specified_identity = None
        other_identities: List[Tuple[int, bytes, int, bytes]] = []

        for _ in range(num_identities):
            key_len = struct.unpack(">I", msg_data[offset:offset+4])[0]
            current_key = msg_data[offset+4:offset+4+key_len]
            comment_len = struct.unpack(">I", msg_data[offset+4+key_len:offset+8+key_len])[0]
            comment = msg_data[offset+8+key_len:offset+8+key_len+comment_len]

            if current_key == key:
                specified_identity = (key_len, current_key, comment_len, comment)
            else:
                other_identities.append((key_len, current_key, comment_len, comment))

            offset += 8 + key_len + comment_len

        # Place the specified identity first, followed by the other identities
        filtered_identities = [specified_identity] + other_identities if specified_identity else other_identities
        for ide in filtered_identities:
            print(f"{ide[3]}!r", file=sys.stderr)
        print("---", file=sys.stderr)

        new_msg_data = struct.pack(">BI", MessageType.IDENTITIES_ANSWER.value, len(filtered_identities))
        for identity in filtered_identities:
            new_msg_data += struct.pack(">I%dsI%ds" % (identity[0], identity[2]), identity[0], identity[1], identity[2], identity[3])

        return new_msg_data

    def get_fingerprint(self, key: bytes) -> str:
        # Calculate the MD5 fingerprint over the correct data
        md5_fingerprint = hashlib.md5(key).hexdigest()
        return md5_fingerprint

    def print_verbose(self, data: bytes, key: bytes, direction: str) -> None:
        fingerprint = self.get_fingerprint(key)
        msg_type = data[4]
        msg_type_str = self.get_msg_type_str(msg_type)
        print(f"{fingerprint} [{direction}]: Message Type: {msg_type_str}", file=sys.stderr)

    def get_msg_type_str(self, msg_type: int) -> str:
        try:
            return MessageType(msg_type).name
        except ValueError:
            return "UNKNOWN"

    async def start_proxy(self) -> None:
        identities = await self.get_identities()

        servers = []

        for identity in identities:
            key = identity[1]
            fingerprint = self.get_fingerprint(key)
            socket_path = self.directory / fingerprint

            server = await asyncio.start_unix_server(lambda r, w, key=key: self.handle_client(r, w, key), str(socket_path))
            servers.append(server)

        # Start all servers concurrently
        await asyncio.gather(*(server.serve_forever() for server in servers))

    async def get_identities(self) -> List[Tuple[int, bytes, int, bytes]]:
        reader, writer = await asyncio.open_unix_connection(self.agent_socket_path)

        # Send REQUEST_IDENTITIES message
        writer.write(struct.pack(">IB", 1, MessageType.REQUEST_IDENTITIES.value))
        await writer.drain()

        # Read response
        data = await reader.read(4)
        if not data:
            return []

        msg_len = struct.unpack(">I", data)[0]
        msg_data = await reader.read(msg_len)

        num_identities = struct.unpack(">I", msg_data[1:5])[0]
        offset = 5
        identities: List[Tuple[int, bytes, int, bytes]] = []

        for _ in range(num_identities):
            key_len = struct.unpack(">I", msg_data[offset:offset+4])[0]
            key = msg_data[offset+4:offset+4+key_len]
            comment_len = struct.unpack(">I", msg_data[offset+4+key_len:offset+8+key_len])[0]
            comment = msg_data[offset+8+key_len:offset+8+key_len+comment_len]

            identities.append((key_len, key, comment_len, comment))

            offset += 8 + key_len + comment_len
            if offset >= len(msg_data):
                break

        writer.close()
        await writer.wait_closed()

        return identities

if __name__ == "__main__":
    agent_socket_path = os.getenv("SSH_AUTH_SOCK")
    if not agent_socket_path:
        print("Error: SSH_AUTH_SOCK environment variable is not set.", file=sys.stderr)
        sys.exit(1)

    home_directory = Path.home()
    directory = home_directory / ".ssh" / "ssh_agent_proxy"
    directory.mkdir(exist_ok=True)

    proxy = SSHAgentProxy(agent_socket_path, directory)
    asyncio.run(proxy.start_proxy())
